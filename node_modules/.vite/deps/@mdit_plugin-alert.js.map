{
  "version": 3,
  "sources": ["../../@mdit/plugin-alert/src/plugins.ts"],
  "sourcesContent": ["import type { PluginWithOptions } from \"markdown-it\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\n\nimport type { MarkdownItAlertOptions } from \"./options.js\";\n\nconst HINT_REGEXP = /^>(?:(?: {0,3})| {0,2}\\t {0,1})\\[!(.*)\\]\\s*$/i;\n\nexport const alert: PluginWithOptions<MarkdownItAlertOptions> = (\n  md,\n  {\n    alertNames = [\"tip\", \"warning\", \"caution\", \"important\", \"note\"],\n    deep = false,\n    openRender,\n    closeRender,\n    titleRender,\n  } = {},\n) => {\n  const alertRule: RuleBlock = (state, startLine, endLine, silent) => {\n    if (\n      // if it's indented more than 3 spaces, it should be a code block\n      state.sCount[startLine] - state.blkIndent >= 4 ||\n      // check whether it's at first level\n      (state.level !== 0 && !deep)\n    )\n      return false;\n\n    const pos = state.bMarks[startLine] + state.tShift[startLine];\n    const max = state.eMarks[startLine];\n\n    // check the block quote marker\n    if (state.src.charAt(pos) !== \">\") return false;\n\n    // check alert markers\n    const match = HINT_REGEXP.exec(state.src.slice(pos, max));\n\n    if (!match || !alertNames.includes(match[1].toLowerCase())) return false;\n\n    // we know that it's going to be a valid alert,\n    // so no point trying to find the end of it in silent mode\n    if (silent) return true;\n\n    const type = match[1].toLowerCase();\n    const oldBMarks = [];\n    const oldBSCount = [];\n    const oldSCount = [];\n    const oldTShift = [];\n    const oldLineMax = state.lineMax;\n    const oldParentType = state.parentType;\n    const terminatorRules = state.md.block.ruler.getRules(\"alert\");\n\n    // @ts-expect-error: We are creating a new type called \"alert\"\n    state.parentType = \"alert\";\n\n    // Search the end of the block\n    //\n    // Block ends with either:\n    //  1. an empty line outside:\n    //     ```\n    //     > test\n    //\n    //     ```\n    //  2. an empty line inside:\n    //     ```\n    //     >\n    //     test\n    //     ```\n    //  3. another tag:\n    //     ```\n    //     > test\n    //      - - -\n    //     ```\n    let nextLine;\n\n    for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n      let adjustTab = false;\n      let lastLineEmpty = false;\n      let pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      const max = state.eMarks[nextLine];\n\n      // check if it's outdented, i.e. it's inside list item and indented\n      // less than said list item:\n      //\n      // ```\n      // 1. anything\n      //    > current blockquote\n      // 2. checking this line\n      // ```\n      const isOutdented = state.sCount[nextLine] < state.blkIndent;\n\n      if (pos >= max)\n        // Case 1: line is not inside the blockquote, and this line is empty.\n        break;\n\n      if (state.src.charAt(pos++) === \">\" && !isOutdented) {\n        let spaceAfterMarker: boolean;\n        // This line is inside the blockquote.\n\n        // set offset past spaces and \">\"\n        let initial = state.sCount[nextLine] + 1;\n\n        // skip one optional space after '>'\n        if (state.src.charAt(pos) === \" \") {\n          // ' >   test '\n          //     ^ -- position start of line here:\n          pos++;\n          initial++;\n          adjustTab = false;\n          spaceAfterMarker = true;\n        } else if (state.src.charAt(pos) === \"\\t\") {\n          spaceAfterMarker = true;\n\n          if ((state.bsCount[nextLine] + initial) % 4 === 3) {\n            // '  >\\t  test '\n            //       ^ -- position start of line here (tab has width===1)\n            pos++;\n            initial++;\n            adjustTab = false;\n          } else {\n            // ' >\\t  test '\n            //    ^ -- position start of line here + shift bsCount slightly\n            //         to make extra space appear\n            adjustTab = true;\n          }\n        } else {\n          spaceAfterMarker = false;\n        }\n\n        let offset = initial;\n\n        oldBMarks.push(state.bMarks[nextLine]);\n        state.bMarks[nextLine] = pos;\n\n        while (pos < max) {\n          const ch = state.src.charAt(pos);\n\n          if (ch === \"\\t\")\n            offset +=\n              4 -\n              ((offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4);\n          else if (ch === \" \") offset++;\n          else break;\n\n          pos++;\n        }\n\n        lastLineEmpty = pos >= max;\n\n        oldBSCount.push(state.bsCount[nextLine]);\n        state.bsCount[nextLine] =\n          state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n        oldSCount.push(state.sCount[nextLine]);\n        state.sCount[nextLine] = offset - initial;\n\n        oldTShift.push(state.tShift[nextLine]);\n        state.tShift[nextLine] = pos - state.bMarks[nextLine];\n        continue;\n      }\n\n      // Case 2: line is not inside the blockquote, and the last line was empty.\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (lastLineEmpty) break;\n\n      // Case 3: another tag found.\n      let terminate = false;\n\n      for (const terminatorRule of terminatorRules)\n        if (terminatorRule(state, nextLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n\n      if (terminate) {\n        // Quirk to enforce \"hard termination mode\" for paragraphs;\n        // normally if you call `tokenize(state, startLine, nextLine)`,\n        // paragraphs will look below nextLine for paragraph continuation,\n        // but if blockquote is terminated by another tag, they shouldn't\n        state.lineMax = nextLine;\n\n        if (state.blkIndent !== 0) {\n          // state.blkIndent was non-zero, we now set it to zero,\n          // so we need to re-calculate all offsets to appear as\n          // if indent wasn't changed\n          oldBMarks.push(state.bMarks[nextLine]);\n          oldBSCount.push(state.bsCount[nextLine]);\n          oldTShift.push(state.tShift[nextLine]);\n          oldSCount.push(state.sCount[nextLine]);\n          state.sCount[nextLine] -= state.blkIndent;\n        }\n\n        break;\n      }\n\n      oldBMarks.push(state.bMarks[nextLine]);\n      oldBSCount.push(state.bsCount[nextLine]);\n      oldTShift.push(state.tShift[nextLine]);\n      oldSCount.push(state.sCount[nextLine]);\n\n      // A negative indentation means that this is a paragraph continuation\n      //\n      state.sCount[nextLine] = -1;\n    }\n\n    const oldIndent = state.blkIndent;\n\n    state.blkIndent = 0;\n\n    const titleLines: [number, number] = [startLine, startLine + 1];\n    const contentLines: [number, number] = [startLine + 1, 0];\n\n    const openToken = state.push(\"alert_open\", \"div\", 1);\n\n    openToken.markup = type;\n    openToken.attrJoin(\"class\", `markdown-alert markdown-alert-${type}`);\n    openToken.map = contentLines;\n\n    const titleToken = state.push(\"alert_title\", \"\", 0);\n\n    titleToken.attrJoin(\"class\", `markdown-alert-title`);\n    titleToken.markup = type;\n    titleToken.content = match[1];\n    titleToken.map = titleLines;\n\n    state.md.block.tokenize(state, startLine + 1, nextLine);\n\n    const closeToken = state.push(\"alert_close\", \"div\", -1);\n\n    closeToken.markup = type;\n\n    state.lineMax = oldLineMax;\n    state.parentType = oldParentType;\n    contentLines[1] = state.line;\n\n    // Restore original tShift; this might not be necessary since the parser\n    // has already been here, but just to make sure we can do that.\n    for (let i = 0; i < oldTShift.length; i++) {\n      state.bMarks[i + startLine] = oldBMarks[i];\n      state.tShift[i + startLine] = oldTShift[i];\n      state.sCount[i + startLine] = oldSCount[i];\n      state.bsCount[i + startLine] = oldBSCount[i];\n    }\n    state.blkIndent = oldIndent;\n\n    return true;\n  };\n\n  md.block.ruler.before(\"blockquote\", \"alert\", alertRule, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n\n  if (openRender) md.renderer.rules.alert_open = openRender;\n  if (closeRender) md.renderer.rules.alert_close = closeRender;\n\n  md.renderer.rules.alert_title =\n    titleRender ??\n    ((tokens, index): string => {\n      const token = tokens[index];\n\n      return `<p class=\"markdown-alert-title\">${\n        token.content[0].toUpperCase() +\n        token.content.substring(1).toLowerCase()\n      }</p>\\n`;\n    });\n};\n"],
  "mappings": "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",
  "names": ["HINT_REGEXP", "alert", "md", "alertNames", "deep", "openRender", "closeRender", "titleRender", "alertRule", "state", "startLine", "endLine", "silent", "pos", "max", "match", "type", "oldBMarks", "oldBSCount", "oldSCount", "oldTShift", "oldLineMax", "oldParentType", "terminatorRules", "nextLine", "adjustTab", "lastLineEmpty", "isOutdented", "spaceAfterMarker", "initial", "offset", "ch", "terminate", "terminatorRule", "oldIndent", "titleLines", "contentLines", "openToken", "titleToken", "closeToken", "i", "tokens", "index", "token"]
}
