import "./chunk-G3PMV62Z.js";

// node_modules/markdown-it-collapsible/dist/esm/index.js
var MARKER = 43;
var MARKER_OPEN = 62;
function renderSummary(tokens, idx, options, env, self) {
  const title = self.render(tokens[idx].children, options, env);
  return `<summary>${title}</summary>`;
}
function skipMarker(state, start) {
  let isOpen = false;
  let pos = state.skipChars(start, MARKER);
  if (state.src.charCodeAt(pos) === MARKER_OPEN) {
    pos++;
    isOpen = true;
  }
  const markerCount = pos - start;
  const marker = String.fromCharCode(MARKER).repeat(Math.max(markerCount - 1, 0)) + (isOpen ? ">" : "+");
  return { pos, isOpen, markerCount, marker };
}
function parseCollapsible(state, startLine, endLine, silent) {
  let autoClosedBlock = false;
  let start = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  let { pos, isOpen, markerCount, marker } = skipMarker(state, start);
  if (markerCount < 3)
    return false;
  const params = state.src.slice(pos, max).trim();
  if (isWhitespace(state, pos, max))
    return false;
  if (params.endsWith(marker))
    return false;
  if (silent)
    return true;
  let nextLine = startLine;
  let isEmpty = true;
  for (; ; ) {
    nextLine++;
    if (nextLine >= endLine)
      break;
    start = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];
    if (start < max && state.sCount[nextLine] < state.blkIndent)
      break;
    if (state.src.charCodeAt(start) !== MARKER) {
      if (isEmpty)
        isEmpty = isWhitespace(state, start, max);
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4)
      continue;
    const endMarker = skipMarker(state, start);
    pos = endMarker.pos;
    if (endMarker.marker !== marker)
      continue;
    pos = state.skipSpaces(pos);
    if (pos < max)
      continue;
    autoClosedBlock = true;
    break;
  }
  if (isEmpty)
    return false;
  const oldParent = state.parentType;
  const oldLineMax = state.lineMax;
  state.parentType = "reference";
  state.lineMax = nextLine;
  let token = state.push("collapsible_open", "details", 1);
  token.block = true;
  token.info = params;
  token.markup = marker;
  token.map = [startLine, nextLine];
  if (isOpen)
    token.attrSet("open", "");
  let tokens = [];
  const markerToken = new state.Token("collapsible_marker", "span", 1);
  markerToken.attrs = [["class", "details-marker"]];
  const markerTokens = [markerToken, new state.Token("collapsible_marker", "span", -1)];
  if (params.match(/^#{1,6}/)) {
    tokens = state.md.parse(params, state.env);
    const headingToken = tokens.shift();
    if (headingToken)
      tokens.unshift(headingToken, ...markerTokens);
  } else {
    state.md.inline.parse(params, state.md, state.env, tokens);
    tokens.unshift(...markerTokens);
  }
  token = state.push("collapsible_summary", "summary", 0);
  token.content = params;
  token.children = tokens;
  state.md.block.tokenize(state, startLine + 1, nextLine);
  token = state.push("collapsible_close", "details", -1);
  token.markup = state.src.slice(start, pos);
  token.block = true;
  state.parentType = oldParent;
  state.lineMax = oldLineMax;
  state.line = nextLine + (autoClosedBlock ? 1 : 0);
  return true;
}
function isWhitespace(state, start, end) {
  for (start; start < end; start++) {
    if (!state.md.utils.isWhiteSpace(state.src.charCodeAt(start)))
      return false;
  }
  return true;
}
function collapsiblePlugin(md) {
  md.block.ruler.before("fence", "collapsible", parseCollapsible, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  });
  md.renderer.rules.collapsible_summary = renderSummary;
}
export {
  collapsiblePlugin as default
};
//# sourceMappingURL=markdown-it-collapsible.js.map
