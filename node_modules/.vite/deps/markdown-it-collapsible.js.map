{
  "version": 3,
  "sources": ["../../markdown-it-collapsible/dist/esm/index.js"],
  "sourcesContent": ["const MARKER = 43; // +\nconst MARKER_OPEN = 62; // >\nfunction renderSummary(tokens, idx, options, env, self) {\n    const title = self.render(tokens[idx].children, options, env);\n    return `<summary>${title}</summary>`;\n}\nfunction skipMarker(state, start) {\n    let isOpen = false;\n    // First, skip all `+` characters\n    let pos = state.skipChars(start, MARKER);\n    // If the next character is `>`, then we are in open state\n    if (state.src.charCodeAt(pos) === MARKER_OPEN) {\n        pos++;\n        isOpen = true;\n    }\n    const markerCount = pos - start;\n    const marker = String.fromCharCode(MARKER).repeat(Math.max(markerCount - 1, 0)) + (isOpen ? \">\" : \"+\");\n    return { pos, isOpen, markerCount, marker };\n}\n/**\n * The core plugin which checks for the appropriate prefix content of\n * either `+++` (for collapsible blocks in closed state) or `++>` (for\n * collapsible blocks in open state).\n */\nfunction parseCollapsible(state, startLine, endLine, silent) {\n    let autoClosedBlock = false;\n    let start = state.bMarks[startLine] + state.tShift[startLine];\n    let max = state.eMarks[startLine];\n    // The block must start with `+++` or `++>`\n    let { pos, isOpen, markerCount, marker } = skipMarker(state, start);\n    if (markerCount < 3)\n        return false;\n    /** The characters of the **summary** section */\n    const params = state.src.slice(pos, max).trim();\n    // Title must not be empty\n    if (isWhitespace(state, pos, max))\n        return false;\n    // The title must not end with the marker (no inline)\n    if (params.endsWith(marker))\n        return false;\n    // Since start is found, we can report success here in validation mode\n    if (silent)\n        return true;\n    // Search the end of the block\n    let nextLine = startLine;\n    let isEmpty = true;\n    for (;;) {\n        nextLine++;\n        // Unclosed block should be autoclosed by end of document.\n        if (nextLine >= endLine)\n            break;\n        start = state.bMarks[nextLine] + state.tShift[nextLine];\n        max = state.eMarks[nextLine];\n        // Non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        if (start < max && state.sCount[nextLine] < state.blkIndent)\n            break;\n        if (state.src.charCodeAt(start) !== (MARKER)) {\n            if (isEmpty)\n                isEmpty = isWhitespace(state, start, max);\n            continue;\n        }\n        // Closing marker should be indented less than 4 spaces\n        if (state.sCount[nextLine] - state.blkIndent >= 4)\n            continue;\n        const endMarker = skipMarker(state, start);\n        pos = endMarker.pos;\n        // Closing marker must match opening marker\n        if (endMarker.marker !== marker)\n            continue;\n        // Make sure tail has spaces only\n        pos = state.skipSpaces(pos);\n        if (pos < max)\n            continue;\n        autoClosedBlock = true;\n        break;\n    }\n    if (isEmpty)\n        return false;\n    const oldParent = state.parentType;\n    const oldLineMax = state.lineMax;\n    state.parentType = \"reference\";\n    // This will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine;\n    // Push the tokens to the state\n    let token = state.push(\"collapsible_open\", \"details\", 1);\n    token.block = true;\n    token.info = params;\n    token.markup = marker;\n    token.map = [startLine, nextLine];\n    if (isOpen)\n        token.attrSet(\"open\", \"\");\n    // Tokenize the summary content\n    let tokens = [];\n    const markerToken = new state.Token(\"collapsible_marker\", \"span\", 1);\n    markerToken.attrs = [[\"class\", \"details-marker\"]];\n    const markerTokens = [markerToken, new state.Token(\"collapsible_marker\", \"span\", -1)];\n    // It doesn't make sense to have block level elements inside the summary,\n    // except for headings. Thus, a simple check is performed to see if the\n    // summary content is a heading.\n    if (params.match(/^#{1,6}/)) {\n        tokens = state.md.parse(params, state.env);\n        const headingToken = tokens.shift();\n        if (headingToken)\n            tokens.unshift(headingToken, ...markerTokens);\n    }\n    // Otherwise, we parse everything as inline\n    else {\n        state.md.inline.parse(params, state.md, state.env, tokens);\n        tokens.unshift(...markerTokens);\n    }\n    token = state.push(\"collapsible_summary\", \"summary\", 0);\n    token.content = params;\n    token.children = tokens;\n    state.md.block.tokenize(state, startLine + 1, nextLine);\n    token = state.push(\"collapsible_close\", \"details\", -1);\n    token.markup = state.src.slice(start, pos);\n    token.block = true;\n    state.parentType = oldParent;\n    state.lineMax = oldLineMax;\n    state.line = nextLine + (autoClosedBlock ? 1 : 0);\n    return true;\n}\nfunction isWhitespace(state, start, end) {\n    for (start; start < end; start++) {\n        if (!state.md.utils.isWhiteSpace(state.src.charCodeAt(start)))\n            return false;\n    }\n    return true;\n}\n/**\n * A markdown-it plugin, which allows authors to create a block of content, which can be toggled between\n * an open and closed state. Use `+++` to start in closed state and `++>` to render an open collapsible block by default.\n *\n * @example\n * ```md\n * +++ Click to open\n * This content is\n * - hidden\n * - invisible\n * - collapsed\n * +++\n * ```\n */\nexport default function collapsiblePlugin(md) {\n    md.block.ruler.before(\"fence\", \"collapsible\", parseCollapsible, {\n        alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n    });\n    md.renderer.rules.collapsible_summary = renderSummary;\n}\n;\n"],
  "mappings": "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",
  "names": []
}
